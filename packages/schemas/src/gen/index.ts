import assert from 'assert';
import camelcase from 'camelcase';
import fs from 'fs/promises';
import path from 'path';
import pluralize from 'pluralize';
import { conditionalString } from '@logto/essentials';

import { findFirstParentheses, getType, normalizeWhitespaces, removeParentheses } from './utils';

type Field = {
  name: string;
  type: string;
  required: boolean;
  isArray: boolean;
};

type Table = {
  name: string;
  fields: Field[];
};

const dir = 'tables';

const generate = async () => {
  const files = await fs.readdir(dir);
  const generated = await Promise.all(
    files
      .filter((file) => file.endsWith('.sql'))
      .map<Promise<[string, Table[]]>>(async (file) => [
        file,
        (
          await fs.readFile(path.join(dir, file), { encoding: 'utf-8' })
        )
          .split(';')
          .map((value) => normalizeWhitespaces(value).toLowerCase())
          .filter((value) => value.startsWith('create table'))
          .map((value) => findFirstParentheses(value))
          .filter((value): value is NonNullable<typeof value> => Boolean(value))
          .map<Table>(({ prefix, body }) => {
            const name = normalizeWhitespaces(prefix).split(' ')[2];
            assert(name, 'Missing table name: ' + prefix);

            const fields = removeParentheses(body)
              .split(',')
              .map((value) => normalizeWhitespaces(value))
              .filter((value) =>
                ['primary', 'foreign', 'unique', 'exclude', 'check'].every(
                  (constraint) => !value.startsWith(constraint + ' ')
                )
              )
              .map<Field>((value) => {
                const [name, type, ...rest] = value.split(' ');
                assert(name && type, 'Missing column name or type: ' + value);

                const restJoined = rest.join(' ');
                // CAUTION: Only works for single dimension arrays
                const isArray = Boolean(/\[.*]/.test(type)) || restJoined.includes('array');
                const required = restJoined.includes('not null');

                return {
                  name,
                  type: getType(type),
                  isArray,
                  required,
                };
              });
            return { name, fields };
          }),
      ])
  );

  const generatedDir = 'src/db-entries';
  const header = '// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n\n';
  const getOutputFileName = (file: string) => pluralize(file.slice(0, -4).replace(/_/g, '-'), 1);

  await fs.rmdir(generatedDir, { recursive: true });
  await fs.mkdir(generatedDir, { recursive: true });
  await Promise.all(
    generated.map(async ([file, tables]) => {
      const content =
        header +
        tables
          .map(({ name, fields }) =>
            [
              `export type ${pluralize(camelcase(name, { pascalCase: true }), 1)}DBEntry = {`,
              ...fields.map(
                ({ name, type, isArray, required }) =>
                  `  ${camelcase(name)}${conditionalString(
                    !required && '?'
                  )}: ${type}${conditionalString(isArray && '[]')};`
              ),
              '};',
              '',
              `export const ${camelcase(name, { pascalCase: true })} = Object.freeze({`,
              `  table: '${name}',`,
              '  fields: {',
              ...fields.map(({ name }) => `    ${camelcase(name)}: '${name}',`),
              '  },',
              '} as const);',
            ].join('\n')
          )
          .join('\n') +
        '\n';
      await fs.writeFile(path.join(generatedDir, getOutputFileName(file) + '.ts'), content);
    })
  );
  await fs.writeFile(
    path.join(generatedDir, 'index.ts'),
    header +
      generated.map(([file]) => `export * from './${getOutputFileName(file)}';`).join('\n') +
      '\n'
  );
};

void generate();
